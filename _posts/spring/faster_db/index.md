# DB Index

## INDEX가 등장하게된 이유

### 기존의 시스템

만약 우리가 직접 데이터베이스에 저장하게 되면 **데이터 블록**으로 저장되게 된다.

이러한 블록들은 접근할 때 **최소 단위**가 된다.

> `These blocks are accessed in their entirety, making them the atomic disk access operation`
>
> 즉 이러한 블록들에 접근하게 되면, 블록 단위로 접근할 수 있다.

블록들은 **연결리스트와 비슷한 형태**를 가지고 있는데, 공통점은 아래와 같다.

- 데이터를 섹션으로 나눠서 저장한다.
- 다음 블록의 주소를 가지고 있다.
- 연속적으로 연결될 필요가 없다.



자료들이 하나의 필드로만 정렬될 수 있다는 특징 때문에 우리는 정렬되지 않은 필드로 검색하려 하면 **선형 검색**을 해야한다.

> 선형 검색(Linear Search)란 **처음부터 끝까지** 순회하며 **각각 모두 비교** 해서 탐색하는 방법이다.

이러한 선형 검색은 평균적으로 **`블록 개수/2`** 만큼의 블록을 탐색해야 원하는 자료를 검색할 수 있다.

> UNIQUE한 필드라면 제일 처음 찾은 후 탐색을 종료해도 되기 때문이다.

만약 UNIQUE한 필드가 아니라면 **블록 개수**만큼의 블록을 **전부** 탐색해야 하는 일이 발생한다.

> 이러한 일을 Full Scan이라고 한다.



만약 정렬 된 속성이라면 **이진 검색 알고리즘**을 사용할 수 있다.

> 이진 검색 알고리즘은 `log₂ N`의 시간 복잡도를 가지고 있는데, **정렬이 되어있을 때**만 사용할 수 있다.

또한 키가 아닌 필드에 따라 정렬되었기 때문에 원하는 값을 발견했다면 더 높은 값을 탐색할 필요가 없다.

> `since the data is sorted given a non-key field, the rest of the table doesn’t need to be searched for duplicate values, once a higher value is found. Thus the performance increase is substantial.`



## Index란?

**추가적인 공간**을 활용해서 **조회의 성능 향상**을 위해 사용되는 자료구조 이다.

**여러가지 필드**를 통해 자료를 **정렬**하는 것을 의미한다.

> 만약 index가 없을 때 id가 10000인 데이터를 찾으려면, 테이블의 모든 데이터를 순회하며 찾아야 한다.



Index란 **지정한 컬럼**을 기준으로 **목차**를 생성하는 것으로, **조회의 성능 향상**을 목적으로 사용된다.

반대로 삭제, 수정, 삽입의 성능은 떨어지게 된다.

> 원래 수정, 삭제는 작업 전 조회를 하게 되는데, 여기서 전체적인 작업(조회 + 삭제)이 느려지는게 아니라 삭제 작업만 느려지게 된다.
>
> 즉 **전체적인 수정/삭제 작업의 속도가 느려진다는건 아니고, 오히려 빨라진다.**



그림으로 보면 다음과 같다.

<img src=".\images\index_basic.jpg" alt="index_basic" style="zoom:100%;" />

즉 인덱스를 사용하게 되면 직접 테이블에 접근하는게 아니라, **INDEX를 통해 실제 테이블에 간접적으로 접근한다.**

인덱스에 접근한 후에, KEY - VALUE 형태로 되어있는 INDEX에서 **주소를 찾아 실제 테이블에 접근한다.**



> 자세히 설명하면 실제 자료들에서 추출된 몇몇 속성들로 이루어진 자료구조를 만들게 된다.
>
> 해당 자료 구조는 실제에서 자료들의 주소를 가지고 있고, 정렬되어 있어 2진 탐색을 할 수 있다.



#### 성능이 느려지는 이유

DBMS가 조회를 사용하려 하면 INDEX를 항상 최신 상태로 유지해야 한다.

> 삽입이 일어났는데 INDEX가 수정되지 않았다면, INSERT된 값은 조회 결과로 들어오지 않기 때문이다.

따라서 삽입, 수정, 삭제 시에 **INDEX를 수정하기 위한 추가 오버헤드가 발생한다.**

- 삽입

  새로운 데이터를 인덱스에 추가한다.

- 삭제

  삭제된 데이터의 인덱스를 **사용하지 않도록 함**

- 수정

  기존의 인덱스를 **미사용 처리**하고 **갱신된 데이터를 인덱스에 추가**한다.



## INDEX의 장단점

### 장점

- 테이블 조회 성능을 증가시킬 수 있다.

- 전반적인 시스템의 부하를 줄일 수 있다.

  만약 INDEX가 없을 때 FULL SCAN이 발생할 상황을 훨씬 쉽고 부하가 적게 조회한다.

### 단점

- 인덱스를 관리하기 위한 공간이 필요하다.

  > DB의 10% 정도 차지하게 된다.

- 인덱스 관리를 위한 추가 작업이 필요하다.

- 잘 못 사용할 경우, 오히려 성능이 저하될 수 있다.

  이유는 삭제와 수정이 인덱스를 **삭제하지 않고 사용하지 않음 처리하기 때문이다.**

  즉 수정 삭제가 빈번한 테이블에 인덱스를 사용하게 되면 **실제 데이터보다 훨씬 더 많은 인덱스 때문에 성능이 저하된다.**

따라서 사용하지 않는 인덱스는 지워주는게 좋다.



### 인덱스를 사용하면 좋은 경우

- 규모가 큰 테이블
- 삽입, 수정, 삭제가 자주 일어나지 않는 컬럼
- JOIN, ORDER BY, WHERE이 자주 일어나는 컬럼
- 데이터 중복도가 낮은 컬럼



### 자료구조

#### Hash 인덱스 알고리즘

**컬럼의 해시 값**을 계산해서 인덱싱 하는 알고리즘

하지만 값을 변형하기 때문에, `like`나 `<`(부등호 연산)의 사용이 불가능하다.

주로 메모리 기반 데이터베이스 (redis 등)에서 사용된다.

시간 복잡도가 O(1)로, 굉장히 빠르다.



#### B+Tree 알고리즘

B Tree의 알고리즘의 변형된 형태로, 기존의 B Tree가 노드에 key와 value를 저장했던 것에 반해 B+Tree는 **노드에 key만 담아두고, value는 저장하지 않는다.**

오직 리프 노드에만 데이터를 저장하기 때문에 메모리를 더 확보할 수 있고, 더 많은 key들을 수용할 수 있다는 장점이 있다.



<img src=".\images\bplustree.jpg" alt="bplus" style="zoom: 80%;" />

대부분의 인덱싱 알고리즘에서 사용된다.

특정 컬럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱 한다.

즉 **`like`를 통한 검색이나 부등호 탐색이 가능**하기 때문에 index에서 사용할 때, 동등 연산에 특화된 해쉬 알고리즘보다 인덱스에 적합하다.